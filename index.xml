<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dean Glc</title>
    <link>https://glc.im/</link>
    <description>Recent content on Dean Glc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://glc.im/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://glc.im/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://glc.im/about/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://gongluchen.com&#34;&gt;Click&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>IO模型整理</title>
      <link>https://glc.im/post/io%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 07 Mar 2019 16:42:50 +0800</pubDate>
      
      <guid>https://glc.im/post/io%E6%A8%A1%E5%9E%8B/</guid>
      
        <description>

&lt;h1 id=&#34;5种io模型&#34;&gt;5种IO模型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO复用模型&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂且理解I为input,O为output,即输入和输出.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5b94e93b5188255c672e901e&#34;&gt;refer:漫话：如何给女朋友解释什么是Linux的五种IO模型？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以钓鱼的例子解释IO模型&lt;/p&gt;

&lt;p&gt;###阻塞IO模型:&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。&lt;/p&gt;

&lt;h3 id=&#34;非阻塞io模型&#34;&gt;非阻塞IO模型:&lt;/h3&gt;

&lt;p&gt;阻塞IO模型中等待鱼儿咬钩的时间可以做别的吗?如果可以做别的,那可能就是非阻塞IO模型了.&lt;/p&gt;

&lt;p&gt;非阻塞IO模型中,应用进程和内核会进行交互,目的未达到之前,不再一味的等着,而是直接返回.然后通过轮询的方式,不停的去问内核数据有没有准备好.一旦某一次的轮询发现数据准备好了,那就把数据拷贝到用户空间中.&lt;/p&gt;

&lt;p&gt;应用进程通过 &lt;code&gt;recvfrom&lt;/code&gt; 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回&lt;code&gt;error&lt;/code&gt;，应用进程在得到&lt;code&gt;error&lt;/code&gt;后，过一段时间再发送&lt;code&gt;recvfrom&lt;/code&gt;请求。在两次发送请求的时间段，进程可以先做别的事情。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。&lt;/p&gt;

&lt;h3 id=&#34;信号驱动模型&#34;&gt;信号驱动模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。&lt;/p&gt;

&lt;p&gt;应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;信号驱动模型只有一根鱼竿,多根鱼竿就是IO复用模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;io复用模型&#34;&gt;IO复用模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/p&gt;

&lt;p&gt;IO多路转接是多了一个&lt;code&gt;select&lt;/code&gt;函数，多个进程的IO可以注册到同一个&lt;code&gt;select&lt;/code&gt;上，当用户进程调用该&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;select&lt;/code&gt;会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，&lt;code&gt;select&lt;/code&gt;调用进程会阻塞。当任意一个IO所需的数据准备好之后，&lt;code&gt;select&lt;/code&gt;调用就会返回，然后进程在通过&lt;code&gt;recvfrom&lt;/code&gt;来进行数据拷贝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。&lt;/strong&gt;进程在发出&lt;code&gt;select&lt;/code&gt;后，要等到&lt;code&gt;select&lt;/code&gt;监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。&lt;/p&gt;

&lt;p&gt;这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上四种IO模型都是同步的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;异步io模型&#34;&gt;异步IO模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;user&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>IO模型整理</title>
      <link>https://glc.im/post/io%E6%A8%A1%E5%9E%8B2/</link>
      <pubDate>Thu, 07 Mar 2019 16:42:50 +0800</pubDate>
      
      <guid>https://glc.im/post/io%E6%A8%A1%E5%9E%8B2/</guid>
      
        <description>

&lt;h1 id=&#34;5种io模型&#34;&gt;5种IO模型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO复用模型&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂且理解I为input,O为output,即输入和输出.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5b94e93b5188255c672e901e&#34;&gt;refer:漫话：如何给女朋友解释什么是Linux的五种IO模型？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以钓鱼的例子解释IO模型&lt;/p&gt;

&lt;p&gt;###阻塞IO模型:&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。&lt;/p&gt;

&lt;h3 id=&#34;非阻塞io模型&#34;&gt;非阻塞IO模型:&lt;/h3&gt;

&lt;p&gt;阻塞IO模型中等待鱼儿咬钩的时间可以做别的吗?如果可以做别的,那可能就是非阻塞IO模型了.&lt;/p&gt;

&lt;p&gt;非阻塞IO模型中,应用进程和内核会进行交互,目的未达到之前,不再一味的等着,而是直接返回.然后通过轮询的方式,不停的去问内核数据有没有准备好.一旦某一次的轮询发现数据准备好了,那就把数据拷贝到用户空间中.&lt;/p&gt;

&lt;p&gt;应用进程通过 &lt;code&gt;recvfrom&lt;/code&gt; 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回&lt;code&gt;error&lt;/code&gt;，应用进程在得到&lt;code&gt;error&lt;/code&gt;后，过一段时间再发送&lt;code&gt;recvfrom&lt;/code&gt;请求。在两次发送请求的时间段，进程可以先做别的事情。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。&lt;/p&gt;

&lt;h3 id=&#34;信号驱动模型&#34;&gt;信号驱动模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。&lt;/p&gt;

&lt;p&gt;应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;信号驱动模型只有一根鱼竿,多根鱼竿就是IO复用模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;io复用模型&#34;&gt;IO复用模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/p&gt;

&lt;p&gt;IO多路转接是多了一个&lt;code&gt;select&lt;/code&gt;函数，多个进程的IO可以注册到同一个&lt;code&gt;select&lt;/code&gt;上，当用户进程调用该&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;select&lt;/code&gt;会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，&lt;code&gt;select&lt;/code&gt;调用进程会阻塞。当任意一个IO所需的数据准备好之后，&lt;code&gt;select&lt;/code&gt;调用就会返回，然后进程在通过&lt;code&gt;recvfrom&lt;/code&gt;来进行数据拷贝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。&lt;/strong&gt;进程在发出&lt;code&gt;select&lt;/code&gt;后，要等到&lt;code&gt;select&lt;/code&gt;监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。&lt;/p&gt;

&lt;p&gt;这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上四种IO模型都是同步的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;异步io模型&#34;&gt;异步IO模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;user&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>IO模型整理</title>
      <link>https://glc.im/post/io%E6%A8%A1%E5%9E%8B3/</link>
      <pubDate>Thu, 07 Mar 2019 16:42:50 +0800</pubDate>
      
      <guid>https://glc.im/post/io%E6%A8%A1%E5%9E%8B3/</guid>
      
        <description>

&lt;h1 id=&#34;5种io模型&#34;&gt;5种IO模型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO复用模型&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂且理解I为input,O为output,即输入和输出.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5b94e93b5188255c672e901e&#34;&gt;refer:漫话：如何给女朋友解释什么是Linux的五种IO模型？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以钓鱼的例子解释IO模型&lt;/p&gt;

&lt;p&gt;###阻塞IO模型:&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。&lt;/p&gt;

&lt;h3 id=&#34;非阻塞io模型&#34;&gt;非阻塞IO模型:&lt;/h3&gt;

&lt;p&gt;阻塞IO模型中等待鱼儿咬钩的时间可以做别的吗?如果可以做别的,那可能就是非阻塞IO模型了.&lt;/p&gt;

&lt;p&gt;非阻塞IO模型中,应用进程和内核会进行交互,目的未达到之前,不再一味的等着,而是直接返回.然后通过轮询的方式,不停的去问内核数据有没有准备好.一旦某一次的轮询发现数据准备好了,那就把数据拷贝到用户空间中.&lt;/p&gt;

&lt;p&gt;应用进程通过 &lt;code&gt;recvfrom&lt;/code&gt; 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回&lt;code&gt;error&lt;/code&gt;，应用进程在得到&lt;code&gt;error&lt;/code&gt;后，过一段时间再发送&lt;code&gt;recvfrom&lt;/code&gt;请求。在两次发送请求的时间段，进程可以先做别的事情。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。&lt;/p&gt;

&lt;h3 id=&#34;信号驱动模型&#34;&gt;信号驱动模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。&lt;/p&gt;

&lt;p&gt;应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;信号驱动模型只有一根鱼竿,多根鱼竿就是IO复用模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;io复用模型&#34;&gt;IO复用模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/p&gt;

&lt;p&gt;IO多路转接是多了一个&lt;code&gt;select&lt;/code&gt;函数，多个进程的IO可以注册到同一个&lt;code&gt;select&lt;/code&gt;上，当用户进程调用该&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;select&lt;/code&gt;会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，&lt;code&gt;select&lt;/code&gt;调用进程会阻塞。当任意一个IO所需的数据准备好之后，&lt;code&gt;select&lt;/code&gt;调用就会返回，然后进程在通过&lt;code&gt;recvfrom&lt;/code&gt;来进行数据拷贝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。&lt;/strong&gt;进程在发出&lt;code&gt;select&lt;/code&gt;后，要等到&lt;code&gt;select&lt;/code&gt;监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。&lt;/p&gt;

&lt;p&gt;这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上四种IO模型都是同步的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;异步io模型&#34;&gt;异步IO模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;user&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>IO模型整理</title>
      <link>https://glc.im/post/io%E6%A8%A1%E5%9E%8B4/</link>
      <pubDate>Thu, 07 Mar 2019 16:42:50 +0800</pubDate>
      
      <guid>https://glc.im/post/io%E6%A8%A1%E5%9E%8B4/</guid>
      
        <description>

&lt;h1 id=&#34;5种io模型&#34;&gt;5种IO模型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO复用模型&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂且理解I为input,O为output,即输入和输出.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5b94e93b5188255c672e901e&#34;&gt;refer:漫话：如何给女朋友解释什么是Linux的五种IO模型？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以钓鱼的例子解释IO模型&lt;/p&gt;

&lt;p&gt;###阻塞IO模型:&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。&lt;/p&gt;

&lt;h3 id=&#34;非阻塞io模型&#34;&gt;非阻塞IO模型:&lt;/h3&gt;

&lt;p&gt;阻塞IO模型中等待鱼儿咬钩的时间可以做别的吗?如果可以做别的,那可能就是非阻塞IO模型了.&lt;/p&gt;

&lt;p&gt;非阻塞IO模型中,应用进程和内核会进行交互,目的未达到之前,不再一味的等着,而是直接返回.然后通过轮询的方式,不停的去问内核数据有没有准备好.一旦某一次的轮询发现数据准备好了,那就把数据拷贝到用户空间中.&lt;/p&gt;

&lt;p&gt;应用进程通过 &lt;code&gt;recvfrom&lt;/code&gt; 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回&lt;code&gt;error&lt;/code&gt;，应用进程在得到&lt;code&gt;error&lt;/code&gt;后，过一段时间再发送&lt;code&gt;recvfrom&lt;/code&gt;请求。在两次发送请求的时间段，进程可以先做别的事情。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。&lt;/p&gt;

&lt;h3 id=&#34;信号驱动模型&#34;&gt;信号驱动模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。&lt;/p&gt;

&lt;p&gt;应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;信号驱动模型只有一根鱼竿,多根鱼竿就是IO复用模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;io复用模型&#34;&gt;IO复用模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/p&gt;

&lt;p&gt;IO多路转接是多了一个&lt;code&gt;select&lt;/code&gt;函数，多个进程的IO可以注册到同一个&lt;code&gt;select&lt;/code&gt;上，当用户进程调用该&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;select&lt;/code&gt;会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，&lt;code&gt;select&lt;/code&gt;调用进程会阻塞。当任意一个IO所需的数据准备好之后，&lt;code&gt;select&lt;/code&gt;调用就会返回，然后进程在通过&lt;code&gt;recvfrom&lt;/code&gt;来进行数据拷贝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。&lt;/strong&gt;进程在发出&lt;code&gt;select&lt;/code&gt;后，要等到&lt;code&gt;select&lt;/code&gt;监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。&lt;/p&gt;

&lt;p&gt;这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上四种IO模型都是同步的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;异步io模型&#34;&gt;异步IO模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;user&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>IO模型整理</title>
      <link>https://glc.im/post/io%E6%A8%A1%E5%9E%8B5/</link>
      <pubDate>Thu, 07 Mar 2019 16:42:50 +0800</pubDate>
      
      <guid>https://glc.im/post/io%E6%A8%A1%E5%9E%8B5/</guid>
      
        <description>

&lt;h1 id=&#34;5种io模型&#34;&gt;5种IO模型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO复用模型&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂且理解I为input,O为output,即输入和输出.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5b94e93b5188255c672e901e&#34;&gt;refer:漫话：如何给女朋友解释什么是Linux的五种IO模型？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以钓鱼的例子解释IO模型&lt;/p&gt;

&lt;p&gt;###阻塞IO模型:&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。&lt;/p&gt;

&lt;h3 id=&#34;非阻塞io模型&#34;&gt;非阻塞IO模型:&lt;/h3&gt;

&lt;p&gt;阻塞IO模型中等待鱼儿咬钩的时间可以做别的吗?如果可以做别的,那可能就是非阻塞IO模型了.&lt;/p&gt;

&lt;p&gt;非阻塞IO模型中,应用进程和内核会进行交互,目的未达到之前,不再一味的等着,而是直接返回.然后通过轮询的方式,不停的去问内核数据有没有准备好.一旦某一次的轮询发现数据准备好了,那就把数据拷贝到用户空间中.&lt;/p&gt;

&lt;p&gt;应用进程通过 &lt;code&gt;recvfrom&lt;/code&gt; 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回&lt;code&gt;error&lt;/code&gt;，应用进程在得到&lt;code&gt;error&lt;/code&gt;后，过一段时间再发送&lt;code&gt;recvfrom&lt;/code&gt;请求。在两次发送请求的时间段，进程可以先做别的事情。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。&lt;/p&gt;

&lt;h3 id=&#34;信号驱动模型&#34;&gt;信号驱动模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。&lt;/p&gt;

&lt;p&gt;应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。&lt;/p&gt;

&lt;p&gt;这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;信号驱动模型只有一根鱼竿,多根鱼竿就是IO复用模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;io复用模型&#34;&gt;IO复用模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/p&gt;

&lt;p&gt;IO多路转接是多了一个&lt;code&gt;select&lt;/code&gt;函数，多个进程的IO可以注册到同一个&lt;code&gt;select&lt;/code&gt;上，当用户进程调用该&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;select&lt;/code&gt;会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，&lt;code&gt;select&lt;/code&gt;调用进程会阻塞。当任意一个IO所需的数据准备好之后，&lt;code&gt;select&lt;/code&gt;调用就会返回，然后进程在通过&lt;code&gt;recvfrom&lt;/code&gt;来进行数据拷贝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。&lt;/strong&gt;进程在发出&lt;code&gt;select&lt;/code&gt;后，要等到&lt;code&gt;select&lt;/code&gt;监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。&lt;/p&gt;

&lt;p&gt;这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上四种IO模型都是同步的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;异步io模型&#34;&gt;异步IO模型:&lt;/h3&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;

&lt;p&gt;我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。&lt;/p&gt;

&lt;p&gt;映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;user&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
  </channel>
</rss>